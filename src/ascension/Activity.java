package ascension;

import java.awt.Point;
import java.util.ArrayList;

/**
 * @author Nigel_Baldwen - nigelbaldwen@gmail.com
 * @version 1.0
 */

class Activity implements Comparable<Activity> {

	private PrimaryModel.Player player;
	private int[] activityKeys = new int[2];
	private ArrayList<Point> squaresOccupied, origin, target;
	private AbstractUnit activityRequestor;
	enum ActivityType { MOVEMENT, ATTACK, ABILITY };
	ActivityType activityType;

	/** TODO Fix this comment
	 * Makes a new activity.
	 * 
	 * @param tier - absolute priority
	 * @param relativePriority - relative priority
	 * @param activityType - activity type
	 * @param rowS - the row of the source unit
	 * @param colS - the column of the source unit
	 * @param rowT - the row of the target
	 * @param colT - the column of the target
	 * @param activityRiders - activity riders and effects
	 */
	Activity (PrimaryModel.Player _player, AbstractUnit _activityRequestor, int relativePriority, ActivityType _activityType, int activityRiders, ArrayList<Point> _origin, ArrayList<Point> _target, ArrayList<Point> _squaresOccupied) {
		player = _player;
		activityRequestor = _activityRequestor;
		activityType = _activityType;
		activityKeys[0] = relativePriority;
		activityKeys[1] = activityRiders;
		origin = _origin; // The squares the activity originates from
		target = _target; // The squares affected by the effect of this activity
		squaresOccupied = _squaresOccupied; // The squares the unit is considered to occupy during the activity
	}

	/*
	 * Activity Keys are broken down into the following sections.
	 * activityKeys[0] : tier; this is a reflection of the placement
	 * 		of the activity in relation to the phases
	 * activityKeys[1] : relative priority; this priority is
	 * 		compared to activities within the same activity list
	 * activityKeys[2] : type of action
	 * 		Possible Values :
	 * 			0 : Movement
	 * 			1 : Attack
	 * 			3 : Use Ability
	 * activityKeys[3] : special riders or effects to be applied
	 * 		by an ability
	 */

	/**
	 * Returns the activity keys of this activity.
	 * 
	 * @return the activity keys
	 */
	int[] getActivityKeys() {
		return activityKeys;
	}

	boolean comparePriority(Activity otherAct) {
		System.out.println("This activity priority: " + activityKeys[0]);
		System.out.println("The other activity priority: " + otherAct.activityKeys[0]);
		return (this.activityKeys[0] < otherAct.activityKeys[0] ? true : false);
	}
	
	ArrayList<Point> getTarget() {
		return target;
	}
	
	ArrayList<Point> getOrigin() {
		return origin;
	}
	
	ArrayList<Point> getSquaresOccupied() {
		return squaresOccupied;
	}
	
	PrimaryModel.Player getPlayer() {
		return player;
	}

	AbstractUnit getActivityRequestor() {
		return activityRequestor;
	}
	
	@Override
	public String toString() {
		StringBuilder activityPrint = new StringBuilder();
		activityPrint.append("** == ** This is a " + activityType.toString() + " activity"
				+ " generated by " + player.toString() + ". ** == **\n"
				+ "It originates from the following squares:\n");
		for (int i = 0; i < origin.size(); i++) {
			activityPrint.append("< " + origin.get(i).x + " , " + origin.get(i).y + " >\n");
		}
		activityPrint.append("It occupies the following squares:\n");
		for (int i = 0; i < squaresOccupied.size(); i++) {
			activityPrint.append("< " + squaresOccupied.get(i).x + " , " + squaresOccupied.get(i).y + " >\n");
		}
		activityPrint.append("It targets the following squares:\n");
		for (int i = 0; i < target.size(); i++) {
			activityPrint.append("< " + target.get(i).x + " , " + target.get(i).y + " >\n");
		}
		return activityPrint.toString();
	}

	@Override
	public int compareTo(Activity otherActivity) {
		return this.activityKeys[0] - otherActivity.activityKeys[0];
	}
}